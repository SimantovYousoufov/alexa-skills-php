<?php

namespace AlexaPHP\Tests;

use AlexaPHP\Certificate\Persistence\LocalFileCertificatePersistence;
use AlexaPHP\Exception\AlexaStorageException;
use Carbon\Carbon;
use AlexaPHP\Certificate\Certificate;
use AlexaPHP\Exception\AlexaCertificateException;
use Mockery;

class LocalFileCertificatePersistenceTest extends TestCase
{
	const TEMP_DIR = __DIR__ . '/' . 'temp';

	/**
	 * Start with a cleaned temp dir
	 */
	public function setUp()
	{
		if (is_dir(self::TEMP_DIR)) {
			$this->cleanDir(self::TEMP_DIR);
		}

		return parent::setUp(); // TODO: Change the autogenerated stub
	}

	/**
	 * End with a cleaned temp dir
	 */
	public function tearDown()
	{
		parent::tearDown(); // TODO: Change the autogenerated stub

		if (is_dir(self::TEMP_DIR)) {
			$this->cleanDir(self::TEMP_DIR);
		}
	}

	public function certContents()
	{
		return file_get_contents(__DIR__ . '/test_cert.pem');
	}

	// http://stackoverflow.com/questions/7288029/php-delete-directory-that-is-not-empty
	public function cleanDir($dir) {
		foreach(scandir($dir) as $file) {
			if ('.' === $file || '..' === $file) {
				continue;
			}

			if (is_dir("$dir/$file")) {
				$this->cleanDir("$dir/$file");
			} else {
				unlink("$dir/$file");
			}
		}

		rmdir($dir);
	}

	public function testItAcceptsAndSetsStorageDirectory()
	{
		$temp_dir = self::TEMP_DIR;

		$this->assertFalse(is_dir($temp_dir)); // Should not be a directory yet

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);

		$this->assertTrue(is_dir($temp_dir));

		$metadata = json_decode(file_get_contents($temp_dir . '/alexaphp_meta.json'), true);

		$this->assertEquals(['certificates' => []], $metadata);
	}

	public function testItDoesNotOverwriteExistingDirAndData()
	{
		$temp_dir = self::TEMP_DIR;

		$this->assertFalse(is_dir($temp_dir)); // Should not be a directory yet

		$certificate = Mockery::mock(Certificate::class);
		$certificate->shouldReceive('getEndDate')->andReturn(Carbon::createFromTimestamp(1234567890));
		$certificate->shouldReceive('getContents')->andReturn('cert_contents');

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);
		$persistence->storeCertificateForKey('some_url', $certificate);

		unset($persistence);

		$this->assertTrue(is_dir($temp_dir)); // Should still exist

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);

		$metadata = json_decode(file_get_contents($temp_dir . '/alexaphp_meta.json'), true);

		$json_should_still_be = [
			'certificates' => [
				'some_url' => [
					'url' => 'some_url',
					'location' => self::TEMP_DIR . '/certificates/' . md5('some_url') . '.pem',
					'expires' => 1234567890,
				],
			],
		];

		$this->assertEquals($json_should_still_be, $metadata);
		$this->assertEquals('cert_contents', file_get_contents($json_should_still_be['certificates']['some_url']['location']));

		$new_certificate = Mockery::mock(Certificate::class);
		$new_certificate->shouldReceive('getEndDate')->andReturn(Carbon::createFromTimestamp(1234567890100));
		$new_certificate->shouldReceive('getContents')->andReturn('cert_contents2');

		// Write a new certificate to disk, we should only get additions and not overwrites
		$persistence->storeCertificateForKey('some_url2', $new_certificate);

		$json_should_now_be = [
			'certificates' => [
				'some_url' => [
					'url' => 'some_url',
					'location' => self::TEMP_DIR . '/certificates/' . md5('some_url') . '.pem',
					'expires' => 1234567890,
				],
				'some_url2' => [
					'url' => 'some_url2',
					'location' => self::TEMP_DIR . '/certificates/' . md5('some_url2') . '.pem',
					'expires' => 1234567890100,
				],
			],
		];

		$new_metadata = json_decode(file_get_contents($temp_dir . '/alexaphp_meta.json'), true);

		$this->assertEquals($json_should_now_be, $new_metadata);
	}

	public function testItCanRetrieveCertificateForKey()
	{
		$temp_dir = self::TEMP_DIR;

		$contents_should_be = $this->certContents();

		$certificate = Mockery::mock(Certificate::class);
		$certificate->shouldReceive('getEndDate')->andReturn(Carbon::now()->addHour());
		$certificate->shouldReceive('getContents')->andReturn($contents_should_be);

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);
		$persistence->storeCertificateForKey('some_url', $certificate);

		unset($persistence);

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);

		$stored_certificate = $persistence->getCertificateForKey('some_url');

		$this->assertTrue($stored_certificate instanceof Certificate);

		$this->assertEquals($contents_should_be, $stored_certificate->getContents());
	}

	public function testItReturnsFalseIfFileDoesNotExist()
	{
		$temp_dir = self::TEMP_DIR;

		$contents_should_be = $this->certContents();

		$certificate = Mockery::mock(Certificate::class);
		$certificate->shouldReceive('getEndDate')->andReturn(Carbon::now()->addHour());
		$certificate->shouldReceive('getContents')->andReturn($contents_should_be);

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);
		$persistence->storeCertificateForKey('some_url', $certificate);

		unset($persistence);

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);

		$this->cleanDir(self::TEMP_DIR . '/certificates');

		$stored_certificate = $persistence->getCertificateForKey('some_url');

		$this->assertFalse($stored_certificate);
	}

	public function testItReturnsFalseIfCertificateHasExpired()
	{
		$temp_dir = self::TEMP_DIR;

		$contents_should_be = $this->certContents();

		$certificate = Mockery::mock(Certificate::class);
		$certificate->shouldReceive('getEndDate')->andReturn(Carbon::now()->subHour());
		$certificate->shouldReceive('getContents')->andReturn($contents_should_be);

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);
		$persistence->storeCertificateForKey('some_url', $certificate);

		unset($persistence);

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);

		$stored_certificate = $persistence->getCertificateForKey('some_url');

		$this->assertFalse($stored_certificate);
	}

	public function testItCanExpireCertificateForKey()
	{
		$temp_dir = self::TEMP_DIR;

		$certificate = Mockery::mock(Certificate::class);
		$certificate->shouldReceive('getEndDate')->andReturn(Carbon::now()->addHour());
		$certificate->shouldReceive('getContents')->andReturn('cert_contents');

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);
		$persistence->storeCertificateForKey('some_url', $certificate);

		unset($persistence);

		$this->assertTrue(is_dir($temp_dir)); // Should still exist

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);
		$persistence->expireCertificateForKey('some_url');

		$metadata = json_decode(file_get_contents($temp_dir . '/alexaphp_meta.json'), true);

		$json_should_be = [
			'certificates' => [],
		];

		$this->assertEquals($json_should_be, $metadata);
		$this->assertTrue(! file_exists(self::TEMP_DIR . '/certificates/' . md5('some_url')));
	}

	public function testItReturnsMD5HashForCertificateFilename()
	{
		$temp_dir = self::TEMP_DIR;

		$certificate = Mockery::mock(Certificate::class);
		$certificate->shouldReceive('getEndDate')->andReturn(Carbon::now()->addHour());
		$certificate->shouldReceive('getContents')->andReturn('cert_contents');

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);
		$this->assertEquals(self::TEMP_DIR . '/certificates/' . md5('some_url') . '.pem', $persistence->getFilenameForCertificate('some_url'));
	}

	public function testItCanReturnStorageDir()
	{
		$temp_dir = self::TEMP_DIR;

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);

		$this->assertEquals(self::TEMP_DIR, $persistence->getStorageDirectory());
	}

	public function testItCanReturnCertificateFilesDir()
	{
		$temp_dir = self::TEMP_DIR;

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);

		$this->assertEquals(self::TEMP_DIR . '/certificates', $persistence->getCertificateFilesDirectory());
	}

	public function testItCanReturnMetadataFilename()
	{
		$temp_dir = self::TEMP_DIR;

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);

		$this->assertEquals(self::TEMP_DIR . '/alexaphp_meta.json', $persistence->getMetadataFilename());
	}

	public function testItThrowsExceptionWhenCantUpdateMetadata()
	{
		$temp_dir = self::TEMP_DIR;

		$certificate = Mockery::mock(Certificate::class);
		$certificate->shouldReceive('getEndDate')->andReturn(Carbon::now()->addHour());
		$certificate->shouldReceive('getContents')->andReturn('cert_contents');

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);

		$this->cleanDir($temp_dir);

		$this->setExpectedException(AlexaStorageException::class, 'Failed to store certificate metadata.');
		$persistence->storeCertificateForKey('some_url', $certificate);
	}

	public function testItThrowsExceptionWhenCantWriteCertificateFile()
	{
		$temp_dir = self::TEMP_DIR;

		$certificate = Mockery::mock(Certificate::class);
		$certificate->shouldReceive('getEndDate')->andReturn(Carbon::now()->addHour());
		$certificate->shouldReceive('getContents')->andReturn('cert_contents');

		$persistence = new LocalFileCertificatePersistence(['storage_dir' => $temp_dir]);

		$this->cleanDir($temp_dir . '/certificates');

		$this->setExpectedException(AlexaStorageException::class, 'Failed to store certificate.');
		$persistence->storeCertificateForKey('some_url', $certificate);
	}
}
